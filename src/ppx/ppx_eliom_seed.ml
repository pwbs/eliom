open Parsetree
open Ast_helper

(** Various misc functions *)

let flatmap f l = List.flatten @@ List.map f l


module type Helpers = sig

  (** find infered type for escaped expr *)
  val find_client_value_type: Int64.t -> core_type

  (** find infered type for escaped expr *)
  val find_escaped_ident_type: string -> core_type

  (** find infered type for injected ident *)
  val find_injected_ident_type: string -> core_type

  val is_client_value_type : core_type -> core_type option

  val raise_syntax_error : _ Location.loc -> string -> _

  val is_escaped_indent_string: string -> bool
end


(** Identifiers generated by the eliom syntax extensions. *)

let escaped_ident_prefix = "__eliom__escaped_ident__reserved_name__"

let client_value_ident_prefix = "__eliom__client_value__reserved_name__"

let injected_ident_fmt : (_,_,_,_) format4 =
  "__eliom__injected_ident__reserved_name__%019d__%d"


let escaped_ident_prefix_len = String.length escaped_ident_prefix
let is_escaped_ident_string id =
  String.length id > escaped_ident_prefix_len &&
  String.sub id 0 escaped_ident_prefix_len = escaped_ident_prefix



type client_value_context = [ `Server | `Shared ]
type injection_context    = [ `Client | `Shared ]

let context_to_string = function
  | `Client -> "client"
  | `Shared -> "shared"
  | `Server -> "server"

type escape_inject =
  | Escaped_value of client_value_context
  | Injection of injection_context

let id_of_string str =
  Printf.sprintf "%019d" (Hashtbl.hash str)


(** Signature of specific code of a preprocessor. *)
module type Pass = sig

  (** How to handle "client", "shared" and "server" sections for top level structure items. *)

  val shared_str_item: structure_item -> structure_item list
  val server_str_item: structure_item -> structure_item list
  val client_str_item: structure_item -> structure_item list

  (** How to handle "client", "shared" and "server" sections for top level signature items. *)

  val shared_sig_item: signature_item -> signature_item list
  val client_sig_item: signature_item -> signature_item list
  val server_sig_item: signature_item -> signature_item list

  (** How to handle "[%cval ...]" expr. *)
  val client_value_expr:
    ?typ:core_type -> context:client_value_context ->
    id:Int64.t -> expression -> expression

  (** How to handle escaped "~%ident" inside "[%cval ... ]". *)
  val escape_inject:
    ?ident:string -> context:escape_inject -> expression -> string -> expression

  val implem : structure_item -> structure_item

end

type context =
  | Server (* [%%server ... ] *)
  | Client (* [%%client ... ] *)
  | Shared (* [%shared  ... ] *)
  | Client_value of client_value_context (* [%cval ... ] *)
  | Escaped_value of client_value_context (* [%cval .... ~%x ... ] *)
  | Injection of injection_context (* [%%client .... ~%x ... ] *)


(* Identifiers for the closure representing "Hole_expr". *)
let gen_closure_num_base _loc =
  Int64.of_int (Hashtbl.hash !Location.input_name)
let gen_closure_num_count = ref Int64.zero
let gen_closure_num _loc =
  gen_closure_num_count := Int64.succ !gen_closure_num_count;
  Int64.add (gen_closure_num_base _loc) !gen_closure_num_count
let gen_closure_escaped_ident id =
  client_value_ident_prefix ^ Int64.to_string id

(* Globaly unique ident for escaped expression *)
(* It's used for type inference and as argument name for the
   closure representing the surrounding "Hole_expr". *)
(* Inside a "Hole_expr", same ident share the global ident. *)
let escaped_idents = ref []
let reset_escaped_ident () = escaped_idents := []
let gen_escaped_expr_ident, gen_escaped_ident =
  let r = ref 0 in
  (fun () ->
     incr r;
     escaped_ident_prefix ^ string_of_int !r),
  (fun {Location. txt = id ; loc } ->
     Location.mkloc
       (try List.assoc id !escaped_idents
        with Not_found ->
          incr r; let gen_id = escaped_ident_prefix ^ string_of_int !r in
          escaped_idents := (id, gen_id) :: !escaped_idents;
          gen_id
       )
       loc
  )


let gen_injected_expr_ident, gen_injected_ident =
  let injected_idents = ref [] in
  let r = ref 0 in
  let gen_ident () =
    let hash = Hashtbl.hash !Location.input_name in
    incr r;
    Printf.sprintf injected_ident_fmt hash !r
  in
  let gen_injected_ident {Location. txt = id ; loc } =
    Location.mkloc
      (try List.assoc id !injected_idents
       with Not_found ->
         let gen_id = gen_ident () in
         injected_idents := (id, gen_id) :: !injected_idents;
         gen_id
      )
      loc
  in
  gen_ident, gen_injected_ident



module Register (Pass : Pass) = struct

  let eliom_expr context mapper expr =
    let previous_context = !context in
    let loc = expr.pexp_loc in
    let new_expr = match expr with
      | [%expr [%cval [%e? expr]]] -> begin

          let (cval, typ) = match expr with
            | [%expr ([%e? cval]:[%t? typ]) ] -> (cval, Some typ)
            | _ -> (expr, None)
          in

          let id = gen_closure_num cval.pexp_loc in

          match previous_context with
          | Server ->
            context := Client_value `Server ;
            let e = mapper @@ Pass.client_value_expr ~context:`Server ~id cval in
            context := previous_context ;
            e
          | Shared ->
            context := Client_value `Shared ;
            let e = mapper @@ Pass.client_value_expr ~context:`Shared ~id cval in
            context := previous_context ;
            e
          | Client ->
            Exp.extension @@ Ast_mapper.extension_of_error @@
            Location.error ~loc
              "The syntax [%cval ...] is not allowed inside client code."
          | Client_value _ | Escaped_value _ | Injection _ ->
            Exp.extension @@ Ast_mapper.extension_of_error @@
            Location.error ~loc
              "The syntax [%cval ...] can not be nested."
        end

      | [%expr ~% [%e? inj ]] -> begin


        end
      | _ -> mapper expr
    in
    context := current_context ;
    new_expr

  let structure_item mapper struct_i =
    let loc = struct_i.pstr_loc in
    match struct_i.pstr_desc with
    | Pstr_extension (({txt= ("server"|"shared"|"client") as section }, _), _) ->
      Str.extension @@ Ast_mapper.extension_of_error @@
      Location.errorf ~loc:struct_i.pstr_loc
        "The extension node %%%s is only allowed at toplevel."
        section
    | _ -> mapper.structure_item mapper struct_i

  let eliom_mapper _args =
    let context = ref `Client in
    { Ast_mapper.default_mapper
      with
        Ast_mapper.

        expr = eliom_expr context ;

        (** Reject sections not at toplevel. *)
        structure_item = structure_item

    }


  (** Toplevel sections in structures. *)
  let toplevel_structure _mapper structs =
    let f struct_i = match struct_i with
      | {pstr_desc = Pstr_extension (({txt="server"}, PStr struct_items), _)} ->
        flatmap Pass.server_str_item struct_items
      | {pstr_desc = Pstr_extension (({txt="shared"}, PStr struct_items), _)} ->
        flatmap Pass.shared_str_item struct_items
      | {pstr_desc = Pstr_extension (({txt="client"}, PStr struct_items), _)} ->
        flatmap Pass.client_str_item struct_items
      | _ -> [struct_i]
    in
    flatmap f structs

  let toplevel_mapper _args =
    { Ast_mapper.default_mapper
      with
        Ast_mapper.
        structure = toplevel_structure ;
    }

end
