open Parsetree
open Ast_helper

(** Various misc functions *)

let flatmap f l = List.flatten @@ List.map f l


module type Helpers = sig

  (** find infered type for escaped expr *)
  val find_client_value_type: Int64.t -> core_type

  (** find infered type for escaped expr *)
  val find_escaped_ident_type: string -> core_type

  (** find infered type for injected ident *)
  val find_injected_ident_type: string -> core_type

  val is_client_value_type : core_type -> core_type option

  val raise_syntax_error : _ Location.loc -> string -> _

  val is_escaped_indent_string: string -> bool
end


(** Identifiers generated by the eliom syntax extensions. *)

let escaped_ident_prefix = "__eliom__escaped_ident__reserved_name__"

let client_value_ident_prefix = "__eliom__client_value__reserved_name__"

let injected_ident_fmt : (_,_,_,_) format4 =
  "__eliom__injected_ident__reserved_name__%019d__%d"




type client_value_context = [ `Server | `Shared ]
type injection_context    = [ `Client | `Shared ]

let context_to_string = function
  | `Client -> "client"
  | `Shared -> "shared"
  | `Server -> "server"

type escape_inject =
  | Escaped_value of client_value_context
  | Injection of injection_context

let id_of_string str =
  Printf.sprintf "%019d" (Hashtbl.hash str)


(** Signature of specific code of a preprocessor. *)

module type Pass = sig

  (** How to handle "client", "shared" and "server" sections for top level structure items. *)

  val shared_str_item: structure_item -> structure_item list
  val server_str_item: structure_item -> structure_item list
  val client_str_item: structure_item -> structure_item list

  (** How to handle "client", "shared" and "server" sections for top level signature items. *)

  val shared_sig_item: signature_item -> signature_item list
  val client_sig_item: signature_item -> signature_item list
  val server_sig_item: signature_item -> signature_item list

  (** How to handle "[%cval ...]" expr. *)
  val client_value_expr:
    ?typ:core_type -> context:client_value_context ->
    id:Int64.t -> expression -> expression

  (** How to handle escaped "~%ident" inside "[%cval ... ]". *)
  val escape_inject:
    ?ident:string -> context:escape_inject -> expression -> string -> expression

  val implem : structure_item -> structure_item

end

type context =
  | Server (* [%%server ... ] *)
  | Client (* [%%client ... ] *)
  | Shared (* [%shared  ... ] *)
  | Client_value of client_value_context (* [%cval ... ] *)
  | Escaped_value of client_value_context (* *)
  | Injection of injection_context


(* Identifiers for the closure representing "Hole_expr". *)
let gen_closure_num_base _loc = Int64.of_int (Hashtbl.hash !Location.input_name)
let gen_closure_num_count = ref Int64.zero
let gen_closure_num _loc =
  gen_closure_num_count := Int64.succ !gen_closure_num_count;
  Int64.add (gen_closure_num_base _loc) !gen_closure_num_count
let gen_closure_escaped_ident id =
  client_value_ident_prefix ^ Int64.to_string id

(* Globaly unique ident for escaped expression *)
(* It's used for type inference and as argument name for the
   closure representing the surrounding "Hole_expr". *)
(* Inside a "Hole_expr", same ident share the global ident. *)
let escaped_idents = ref []
let reset_escaped_ident () = escaped_idents := []
let gen_escaped_expr_ident, gen_escaped_ident =
  let r = ref 0 in
  (fun () ->
     incr r;
     Helpers.escaped_ident_prefix ^ string_of_int !r),
  (fun id ->
     let id = (Ast.map_loc (fun _ -> Loc.ghost))#ident id in
     try List.assoc id !escaped_idents
     with Not_found ->
       incr r; let gen_id = Helpers.escaped_ident_prefix ^ string_of_int !r in
       escaped_idents := (id, gen_id) :: !escaped_idents;
       gen_id)

let gen_injected_expr_ident, gen_injected_ident =
  let injected_idents = ref [] in
  let r = ref 0 in
  let gen_ident loc =
    let hash = Hashtbl.hash (Loc.file_name loc) in
    incr r;
    Printf.sprintf (Helpers.injected_ident_fmt ()) hash !r
  in
  let gen_injected_ident loc id =
    let id = (Ast.map_loc (fun _ -> Loc.ghost))#ident id in
    try List.assoc id !injected_idents
    with Not_found ->
      let gen_id = gen_ident loc in
      injected_idents := (id, gen_id) :: !injected_idents;
      gen_id
  in
  gen_ident, gen_injected_ident



module Register (Pass : Pass) = struct

  let eliom_expr context mapper expr =
    let current_context = !context in
    let loc = expr.pexp_loc in
    let new_expr = match expr with
      | [%expr [%cval [%e? expr]]] ->

        let (cval, typ) = match expr with
          | [%expr ([%e? cval]:[%t? typ]) ] -> (cval, Some typ)
          | _ -> (expr, None)
        in

        let id = gen_closure_num cval.pexp_loc in

        begin match current_context with
          | Server ->
            mapper @@ Pass.client_value_expr ~context:`Server ~id e
          | Shared ->
            mapper @@ Pass.client_value_expr ~context:`Shared ~id e
          | Client ->
            Exp.extension @@ Ast_mapper.extension_of_error @@
            Location.error ~loc
              "The syntax [%cval ...] is not allowed inside client code."
          | Hole_expr _ | Escaped_expr _ | Injected_expr _ ->
            Exp.extension @@ Ast_mapper.extension_of_error @@
            Location.error ~loc
              "The syntax [%cval ...] can not be nested."
        end

      | [%expr ~% [%e? inj ]] ->
        ()
      | _ -> mapper expr
    in
    context := current_context ;
    new_expr

  let structure_item mapper struct_i =
    let loc = struct_i.pstr_loc in
    match struct_i.pstr_desc with
    | Pstr_extension (({txt= ("server"|"shared"|"client") as section }, _), _) ->
      Str.extension @@ Ast_mapper.extension_of_error @@
      Location.errorf ~loc:struct_i.pstr_loc
        "The extension node %%%s is only allowed at toplevel."
        section
    | _ -> mapper.structure_item mapper struct_i

  let eliom_mapper _args =
    let context = ref `Client in
    { Ast_mapper.default_mapper
      with
        Ast_mapper.

        expr = eliom_expr context ;

        (** Reject sections not at toplevel. *)
        structure_item = structure_item

        (* (\** Reject sections not at toplevel. *\) *)
        (* signature_item = (fun mapper sig_i -> *)
        (*   match sig_i with *)
        (*   | [%sig [%server [%e? stuct_items ]]] -> *)
        (*     Ast_mapper.extension_of_error @@ *)
        (*     Location.error ~loc:sig_i.psig_loc "The extension node %server is only allowed at toplevel." *)
        (*   | [%sig [%shared [%e? stuct_items ]]] -> *)
        (*     Ast_mapper.extension_of_error @@ *)
        (*     Location.error ~loc:sig_i.psig_loc "The extension node %shared is only allowed at toplevel." *)
        (*   | [%sig [%client [%e? stuct_items ]]] -> *)
        (*     Ast_mapper.extension_of_error @@ *)
        (*     Location.error ~loc:sig_i.psig_loc "The extension node %client is only allowed at toplevel." *)
        (*   | _ -> mapper sig_i *)
        (* ); *)
    }


  (** Toplevel sections in structures. *)
  let toplevel_structure _mapper structs =
    let f struct_i = match struct_i with
      | {pstr_desc = Pstr_extension (({txt="server"}, PStr struct_items), _)} ->
        flatmap Pass.server_str_item struct_items
      | {pstr_desc = Pstr_extension (({txt="shared"}, PStr struct_items), _)} ->
        flatmap Pass.shared_str_item struct_items
      | {pstr_desc = Pstr_extension (({txt="client"}, PStr struct_items), _)} ->
        flatmap Pass.client_str_item struct_items
      | _ -> [struct_i]
    in
    flatmap f structs

  (** Toplevel sections in signatures. *)
  let toplevel_signature _mapper sigs =
    let f sig_i = match sig_i with
      (* | [%sig [%server [%e? sig_items ]]] -> List.map server_sig_items sig_items *)
      (* | [%sig [%shared [%e? sig_items ]]] -> List.map shared_sig_items sig_items *)
      (* | [%sig [%client [%e? sig_items ]]] -> List.map client_sig_items sig_items *)
      | _ -> [sig_i]
    in
    flatmap f sigs

  let toplevel_mapper _args =
    { Ast_mapper.default_mapper
      with
        Ast_mapper.
        structure = toplevel_structure ;
        signature = toplevel_signature ;
    }

end
